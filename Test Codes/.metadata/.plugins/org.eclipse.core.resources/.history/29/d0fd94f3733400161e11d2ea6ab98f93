#include "userLib/common.h"
#include "userLib/init.h"
#include "userLib/pidController.h"
#include "userLib/movingArray.h"

#define KP_motorA 0.02
#define KI_motorA 0.0
#define KD_motorA 0.0
#define KP_motorB 0.02
#define KI_motorB 0.0
#define KD_motorB 0.0

volatile float desiredRPM[2] = {0.0,0.0}, currentRPM[2] = {0.0,0.0}, out[2] = {0.0,0.0};
int uartReceiveCount = 0;

int main() {
	SysCtlClockSet(SYSCTL_SYSDIV_5|SYSCTL_USE_PLL|SYSCTL_XTAL_16MHZ|SYSCTL_OSC_MAIN);
	initPIDController(A,KP_motorA,KI_motorA,KD_motorA);
	initPIDController(B,KP_motorB,KI_motorB,KD_motorB);
	motorDirInit();
	uart0Init();
	uart5Init();
	pwmInit();
	qeiInit();
	//setPWM(55,A);
	//setPWM(57,B);
	//setPWM(0,A);
	//setPWM(0,B);
	IntMasterEnable();
	while(1) {
		//GraphPlot0(currentRPM[A],desiredRPM[A],currentRPM[B],desiredRPM[B]);
	}
}

void Timer0IntHandler(void) {
	TimerIntClear(TIMER0_BASE, TIMER_TIMA_TIMEOUT);
	// Clear the timer interrupt
}

void UARTIntHandler(void) {
	UARTIntClear(UART5_BASE,UART_INT_RX);
	UART_TransmitString("Inside Interrupt",0);
	char data = UARTCharGet(UART5_BASE);
	float bufferDesiredRPM[2];
	if(data == 0x0A) {
		uartReceiveCount = 0;
	} else {
		switch(uartReceiveCount) {
			case 0:
				bufferDesiredRPM[A] = ((data * ((data & 0x01) ? -1 : 1)));
				break;
			case 1:
				bufferDesiredRPM[B] = ((data * ((data & 0x01) ? -1 : 1)));
				break;
			case 2:
				desiredRPM[A] = bufferDesiredRPM[A];
				desiredRPM[B] = bufferDesiredRPM[B];
				// Ignore motor C
				break;
		}
		uartReceiveCount++;
	}
}

void QEI0IntHandler(void) {
	QEIIntClear(QEI0_BASE, QEI_INTTIMER);
	currentRPM[A] = movingArrayOut(A,calculateRPM(A));
	out[A] += PID(A,desiredRPM[A] - currentRPM[A]);
	setPWM(out[A],A);
}

void QEI1IntHandler(void) {
	QEIIntClear(QEI1_BASE, QEI_INTTIMER);
	currentRPM[B] = movingArrayOut(B,calculateRPM(B));
	out[B] += PID(B,desiredRPM[B] - currentRPM[B]);
	setPWM(out[B],B);
}
